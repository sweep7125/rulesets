name: Generate sing-box rulesets from sources

on:
  schedule:
    - cron: "7 0 * * *"
  workflow_dispatch:

concurrency:
  group: singbox-from-sources
  cancel-in-progress: true

permissions:
  contents: write

env:
  COMMIT_USER_NAME: ${{ github.actor }}
  COMMIT_USER_EMAIL: ${{ github.actor }}@users.noreply.github.com
  DEBIAN_FRONTEND: noninteractive
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Switch to branch sing-box-rulesets (create if missing)
        run: |
          set -Eeuo pipefail
          if git ls-remote --exit-code --heads origin refs/heads/sing-box-rulesets >/dev/null 2>&1; then
            git fetch --no-tags --depth=1 origin refs/heads/sing-box-rulesets:refs/remotes/origin/sing-box-rulesets
            git switch -c sing-box-rulesets --track origin/sing-box-rulesets || git switch sing-box-rulesets
            git pull --ff-only || true
          else
            git switch -c sing-box-rulesets
            find . -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +
            git -c user.email="${COMMIT_USER_EMAIL}" -c user.name="${COMMIT_USER_NAME}" commit --allow-empty -m "init sing-box rules branch"
            git push -u origin HEAD:sing-box-rulesets
          fi

      - name: Compute build hash & decide build
        run: |
          set -Eeuo pipefail
          git fetch --no-tags --depth=1 origin sources || true
          GEOSITE_SUBSET_HASH="$(
            {
              git ls-tree -r --name-only origin/sources:geosite || true
            } | awk 'NF' | while IFS= read -r rel; do
              h="$(git show "origin/sources:geosite/$rel" | sha256sum | cut -d' ' -f1 || echo)"
              printf '%s  %s\n' "$h" "$rel"
            done | LC_ALL=C sort | sha256sum | cut -d' ' -f1
          )"
          GEOIP_SUBSET_HASH="$(
            {
              git ls-tree -r --name-only origin/sources:geoip || true
            } | awk 'NF' | while IFS= read -r rel; do
              h="$(git show "origin/sources:geoip/$rel" | sha256sum | cut -d' ' -f1 || echo)"
              printf '%s  %s\n' "$h" "$rel"
            done | LC_ALL=C sort | sha256sum | cut -d' ' -f1
          )"
          SINGBOX_TAG="$(
            curl -fsSL -H "Authorization: bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
              https://api.github.com/repos/SagerNet/sing-box/releases/latest \
            | jq -r '.tag_name // empty'
          )"
          [[ -n "$SINGBOX_TAG" ]] || SINGBOX_TAG=unknown
          git fetch --no-tags --depth=1 origin main || true
          WORKFLOW_HASH="$(git show origin/main:.github/workflows/sing-box.yml 2>/dev/null | sha256sum | cut -d' ' -f1 || echo none)"
          SRS_BUILD_HASH="$(printf '%s\n%s\n%s\n%s\n' "$GEOSITE_SUBSET_HASH" "$GEOIP_SUBSET_HASH" "$SINGBOX_TAG" "$WORKFLOW_HASH" | sha256sum | cut -d' ' -f1)"
          echo "SRS_BUILD_HASH=$SRS_BUILD_HASH" >> "$GITHUB_ENV"
          PREV_HASH="$(cat srs.hash 2>/dev/null || true)"
          if [[ "$SRS_BUILD_HASH" != "$PREV_HASH" ]]; then
            echo "SRS_NEEDS_BUILD=1" >> "$GITHUB_ENV"
          else
            echo "SRS_NEEDS_BUILD=0" >> "$GITHUB_ENV"
          fi

      - name: Read file list from sources
        id: src
        run: |
          set -Eeuo pipefail
          git fetch --no-tags --depth=1 origin sources
          GEOSITE=$(git ls-tree -r --name-only origin/sources:geosite | tr '\n' ' ')
          GEOIP=$(git ls-tree -r --name-only origin/sources:geoip   | tr '\n' ' ')
          echo "GEOSITE=$GEOSITE" >> "$GITHUB_OUTPUT"
          echo "GEOIP=$GEOIP"     >> "$GITHUB_OUTPUT"

      - name: Install sing-box
        if: env.SRS_NEEDS_BUILD == '1'
        run: |
          set -Eeuo pipefail
          curl -fsSL https://sing-box.app/install.sh | sh

      - name: Prepare converter (temp-only JSON)
        if: env.SRS_NEEDS_BUILD == '1'
        run: |
          set -Eeuo pipefail
          cat > /tmp/sb_convert.py <<'PY'
          import sys, json, re, os
          def write_json(path, rule):
              os.makedirs(os.path.dirname(path), exist_ok=True)
              with open(path, "w", encoding="utf-8") as f:
                  json.dump({"version": 3, "rules": [rule] if rule else []}, f, ensure_ascii=False)
          def strip_anno(s):
              s = re.sub(r'\s+#.*$', '', s); s = re.sub(r'\s+//.*$', '', s); s = re.sub(r'\s+@.*$', '', s)
              return s.strip()
          def geosite_to_json(inp, outp):
              dom, suf, kw, rx = [], [], [], []
              with open(inp, "r", encoding="utf-8", errors="ignore") as f:
                  for raw in f:
                      t = raw.strip().replace('\r','')
                      if not t or t.startswith('#') or t.startswith('//') or t.startswith('include:'):
                          continue
                      if   t.startswith('full:'):    v = strip_anno(t[5:]);  dom.append(v) if v else None
                      elif t.startswith('keyword:'): v = strip_anno(t[8:]);  kw.append(v)  if v else None
                      elif t.startswith('regexp:'):  v = strip_anno(t[7:]);  rx.append(v)  if v else None
                      elif t.startswith('domain:'):  v = strip_anno(t[7:]);  suf.append(v) if v else None
                      else:                          v = strip_anno(t);      suf.append(v) if v else None
              rule = {}
              if dom: rule["domain"] = dom
              if suf: rule["domain_suffix"] = suf
              if kw:  rule["domain_keyword"] = kw
              if rx:  rule["domain_regex"] = rx
              write_json(outp, rule)
          def geoip_to_json(inp, outp):
              nets=[]
              with open(inp, "r", encoding="utf-8", errors="ignore") as f:
                  for raw in f:
                      t = raw.strip()
                      if not t or t.startswith('#') or t.startswith('//'):
                          continue
                      t = re.split(r'\s+#|\s+//', t, 1)[0].strip()
                      if t: nets.append(t)
              rule = {"ip_cidr": nets} if nets else {}
              write_json(outp, rule)
          if __name__ == "__main__":
              kind, inp, outp = sys.argv[1], sys.argv[2], sys.argv[3]
              (geosite_to_json if kind == "geosite" else geoip_to_json)(inp, outp)
          PY

      - name: Build *.srs to repository root (no JSON in repo)
        if: env.SRS_NEEDS_BUILD == '1'
        run: |
          set -Eeuo pipefail
          mkdir -p /tmp/src /tmp/json
          find . -mindepth 1 -maxdepth 1 ! -name '.git' ! -name 'srs.hash' -exec rm -rf {} +
          for f in ${{ steps.src.outputs.GEOSITE }}; do
            git show "origin/sources:geosite/$f" > "/tmp/src/${f}"
            base="${f%.list}"; safe="${base//\//-}"
            tmp_json="/tmp/json/geosite-${safe}.json"
            python3 /tmp/sb_convert.py geosite "/tmp/src/${f}" "$tmp_json"
            sing-box rule-set compile --output "geosite-${safe}.srs" "$tmp_json"
          done
          for f in ${{ steps.src.outputs.GEOIP }}; do
            git show "origin/sources:geoip/$f" > "/tmp/src/${f}"
            base="${f%.list}"; safe="${base//\//-}"
            tmp_json="/tmp/json/geoip-${safe}.json"
            python3 /tmp/sb_convert.py geoip "/tmp/src/${f}" "$tmp_json"
            sing-box rule-set compile --output "geoip-${safe}.srs" "$tmp_json"
          done
          rm -rf /tmp/json /tmp/src
          printf '%s' "${SRS_BUILD_HASH}" > ./srs.hash

      - name: Commit *.srs only
        run: |
          set -Eeuo pipefail
          git config --local user.email "${COMMIT_USER_EMAIL}"
          git config --local user.name  "${COMMIT_USER_NAME}"
          find . -mindepth 1 -maxdepth 1 -type f ! -name '*.srs' ! -name 'srs.hash' -delete
          git add -A
          git diff --staged --quiet && exit 0
          git commit -m "Update sing-box rulesets (*.srs) $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          git push || true
